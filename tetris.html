<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>Tetris Game</title>
  <style>
    body {
      min-height: 100vh;
      background: linear-gradient(135deg, #232526 0%, #414345 100%);
      color: #fff;
      font-family: 'Segoe UI', 'Pretendard', Arial, sans-serif;
      text-align: center;
      margin: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
    }
    h1 {
      font-family: 'Orbitron', 'Segoe UI', Arial, sans-serif;
      font-size: 2.5em;
      letter-spacing: 2px;
      margin-top: 32px;
      margin-bottom: 10px;
      color: #00eaff;
      text-shadow: 0 2px 8px #0ff4, 0 0px 2px #222;
    }
    #tetris {
      background: #181c20;
      margin: 30px auto 10px auto;
      display: block;
      border-radius: 16px;
      border: 6px solid #00eaff;
      box-shadow: 0 8px 32px #00eaff33, 0 2px 8px #000a;
    }
    #score {
      font-size: 1.5em;
      margin: 10px;
      color: #ffeb3b;
      text-shadow: 0 2px 8px #000a;
    }
    #game-over {
      color: #ff4444;
      font-size: 2em;
      display: none;
      font-weight: bold;
      text-shadow: 0 2px 8px #000a, 0 0 2px #fff8;
      margin-bottom: 10px;
    }
    button {
      margin: 10px;
      padding: 12px 32px;
      font-size: 1.1em;
      border: none;
      border-radius: 8px;
      background: linear-gradient(90deg, #00eaff 0%, #00c3ff 100%);
      color: #222;
      font-weight: bold;
      box-shadow: 0 2px 8px #00eaff44;
      cursor: pointer;
      transition: background 0.2s, color 0.2s, transform 0.1s;
    }
    button:hover {
      background: linear-gradient(90deg, #00c3ff 0%, #00eaff 100%);
      color: #111;
      transform: translateY(-2px) scale(1.04);
    }
  </style>
</head>
<body>
  <h1>Tetris Game</h1>
  <canvas id="tetris" width="300" height="600"></canvas>
  <div id="score">점수: 0</div>
  <div id="game-over">Game Over</div>
  <button onclick="restart()">재시작</button>
  <script>
    const COLS = 10, ROWS = 20, BLOCK = 30;
    const canvas = document.getElementById('tetris');
    const ctx = canvas.getContext('2d');
    let board, current, next, score, gameOver, dropInterval, dropTimer;

    const COLORS = [null, '#0ff', '#00f', '#f80', '#ff0', '#0f0', '#f0f', '#f00'];
    const SHAPES = [
      [],
      [[1,1,1,1]], // I
      [[2,0,0],[2,2,2]], // J
      [[0,0,3],[3,3,3]], // L
      [[4,4],[4,4]], // O
      [[0,5,5],[5,5,0]], // S
      [[0,6,0],[6,6,6]], // T
      [[7,7,0],[0,7,7]] // Z
    ];

    function reset() {
      board = Array.from({length: ROWS}, () => Array(COLS).fill(0));
      score = 0;
      gameOver = false;
      document.getElementById('game-over').style.display = 'none';
      document.getElementById('score').textContent = '점수: 0';
      current = randomPiece();
      next = randomPiece();
      clearInterval(dropTimer);
      dropInterval = 500;
      dropTimer = setInterval(drop, dropInterval);
      draw();
    }

    function randomPiece() {
      const type = Math.floor(Math.random() * (SHAPES.length - 1)) + 1;
      const shape = SHAPES[type].map(row => row.slice());
      return { type, shape, x: Math.floor(COLS/2) - Math.ceil(shape[0].length/2), y: 0 };
    }

    function collide(piece, x, y, shape) {
      shape = shape || piece.shape;
      for (let r = 0; r < shape.length; r++) {
        for (let c = 0; c < shape[r].length; c++) {
          if (shape[r][c] && (board[r + y] && board[r + y][c + x]) !== 0) {
            return true;
          }
        }
      }
      return false;
    }

    function merge(piece) {
      for (let r = 0; r < piece.shape.length; r++) {
        for (let c = 0; c < piece.shape[r].length; c++) {
          if (piece.shape[r][c]) {
            board[piece.y + r][piece.x + c] = piece.type;
          }
        }
      }
    }

    function rotate(shape) {
      return shape[0].map((_, i) => shape.map(row => row[i]).reverse());
    }

    function drop() {
      if (!move(0, 1)) {
        merge(current);
        clearLines();
        current = next;
        next = randomPiece();
        if (collide(current, current.x, current.y)) {
          gameOver = true;
          document.getElementById('game-over').style.display = 'block';
          clearInterval(dropTimer);
        }
      }
      draw();
    }

    function move(dx, dy) {
      if (!collide(current, current.x + dx, current.y + dy)) {
        current.x += dx;
        current.y += dy;
        draw();
        return true;
      }
      return false;
    }

    function hardDrop() {
      while (move(0, 1));
      drop();
    }

    function rotatePiece() {
      const rotated = rotate(current.shape);
      if (!collide(current, current.x, current.y, rotated)) {
        current.shape = rotated;
        draw();
      }
    }

    function clearLines() {
      let lines = 0;
      outer: for (let r = ROWS - 1; r >= 0; r--) {
        for (let c = 0; c < COLS; c++) {
          if (!board[r][c]) continue outer;
        }
        board.splice(r, 1);
        board.unshift(Array(COLS).fill(0));
        lines++;
        r++;
      }
      if (lines) {
        score += lines * 100;
        document.getElementById('score').textContent = '점수: ' + score;
        if (dropInterval > 100) {
          dropInterval -= 20 * lines;
          clearInterval(dropTimer);
          dropTimer = setInterval(drop, dropInterval);
        }
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c]) {
            drawBlock(c, r, COLORS[board[r][c]]);
          }
        }
      }
      for (let r = 0; r < current.shape.length; r++) {
        for (let c = 0; c < current.shape[r].length; c++) {
          if (current.shape[r][c]) {
            drawBlock(current.x + c, current.y + r, COLORS[current.type]);
          }
        }
      }
    }

    function drawBlock(x, y, color) {
      // 블록에 그라데이션과 그림자 효과 적용
      const grad = ctx.createLinearGradient(x * BLOCK, y * BLOCK, (x+1) * BLOCK, (y+1) * BLOCK);
      grad.addColorStop(0, color);
      grad.addColorStop(1, '#fff8');
      ctx.fillStyle = grad;
      ctx.save();
      ctx.shadowColor = color + 'cc';
      ctx.shadowBlur = 12;
      ctx.fillRect(x * BLOCK, y * BLOCK, BLOCK - 2, BLOCK - 2);
      ctx.restore();
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#222b';
      ctx.strokeRect(x * BLOCK + 1, y * BLOCK + 1, BLOCK - 4, BLOCK - 4);
    }

    document.addEventListener('keydown', e => {
      if (gameOver) return;
      if (e.key === 'ArrowLeft') move(-1, 0);
      else if (e.key === 'ArrowRight') move(1, 0);
      else if (e.key === 'ArrowDown') move(0, 1);
      else if (e.key === 'ArrowUp') rotatePiece();
      else if (e.key === ' ') hardDrop();
    });

    function restart() {
      reset();
    }

    reset();
  </script>
</body>
</html>
